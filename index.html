<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topo H√∂jds√∂kare (Multi-Layer)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; overflow: hidden; }
        #map { height: 100vh; width: 100%; }
        
        #controls {
            position: absolute; top: 20px; right: 20px;
            background: rgba(255, 255, 255, 0.95); padding: 20px;
            z-index: 1000; border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; gap: 10px;
            width: 300px;
            backdrop-filter: blur(5px);
            margin-right: 50px;
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            z-index: 900; pointer-events: none; display: none; 
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: #333; }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        h3 { margin: 0 0 5px 0; font-size: 18px; color: #333; }

        .live-height-box {
            background-color: #e3f2fd; border: 1px solid #90caf9;
            color: #1565c0; padding: 10px; border-radius: 8px;
            text-align: center; margin-bottom: 5px;
        }
        
        .live-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; font-weight: bold; display: block; margin-bottom: 2px; color: #555; }
        .live-value { font-size: 24px; font-weight: 800; font-family: monospace; }
        .gold-icon { filter: hue-rotate(140deg) saturate(3) brightness(1.1); }

        button { cursor: pointer; border: none; border-radius: 6px; font-weight: bold; transition: background 0.2s; }
        
        .action-btn { 
            background-color: #d9534f; color: white; padding: 12px; font-size: 14px; width: 100%; margin-top: 5px; 
            transition: all 0.3s ease;
        }
        .action-btn:hover { background-color: #c9302c; }
        .action-btn:disabled { background-color: #cccccc; color: #666666; cursor: not-allowed; transform: none; }

        .clear-btn { background-color: #6c757d; color: white; padding: 8px; font-size: 13px; width: 100%; }
        .clear-btn:hover { background-color: #5a6268; }
        .gps-btn { background-color: #007bff; color: white; padding: 8px; font-size: 13px; width: 100%; display: flex; align-items: center; justify-content: center; gap: 6px; }
        .gps-btn:hover { background-color: #0056b3; }
        .icon-btn { background: #f8f9fa; border: 1px solid #ced4da; padding: 0 10px; font-size: 16px; }
        
        .search-group { display: flex; gap: 5px; margin-bottom: 5px; }
        #searchInput { flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 6px; font-size: 14px; outline: none; }
        .control-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .control-label { font-size: 14px; font-weight: 600; color: #444; }
        input[type="number"] { width: 70px; padding: 6px; border: 1px solid #ccc; border-radius: 6px; text-align: right; }
        
        .checkbox-group { display: flex; justify-content: space-between; align-items: center; margin-top: 5px; }
        .checkbox-row { display: flex; gap: 6px; align-items: center; }
        .checkbox-row label { font-size: 13px; cursor: pointer; user-select: none; }
        
        .zoom-badge { background: #e9ecef; color: #495057; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; font-family: monospace; }
        #status { font-size: 13px; font-weight: 500; color: #444; min-height: 1.2em; margin-top:5px; }
        #analysis-canvas, #single-point-canvas { display: none; }

        .popup-header { font-weight: bold; font-size: 14px; display:block; margin-bottom: 2px;}
        .popup-height { font-size: 18px; color: #d9534f; font-weight: 800; display:block; margin-bottom: 5px; }
        .popup-meta { font-size: 11px; color: #666; display:block; margin-bottom: 8px; }
        .coord-box { background: #f1f3f5; border: 1px solid #dee2e6; border-radius: 4px; padding: 4px 8px; display: flex; justify-content: space-between; align-items: center; font-family: monospace; font-size: 12px; gap: 8px; }
        .copy-btn { background: white; border: 1px solid #ced4da; border-radius: 3px; cursor: pointer; padding: 2px 6px; font-size: 12px; }
        .copy-btn:hover { background: #e9ecef; }

        .leaflet-control-layers {
            margin-top: 20px !important; margin-right: 20px !important;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2) !important;
            border-radius: 8px !important; border: none !important;
            font-size: 13px !important;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>

    <div id="controls">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h3>H√∂jds√∂kare</h3>
            <span id="zoom-level" class="zoom-badge">Zoom: 11</span>
        </div>

        <div class="live-height-box">
            <span id="liveLabel" class="live-label">H√ñJD √ñVER HAVET VID MITTPUNKT</span>
            <span id="center-h" class="live-value">-- m</span>
        </div>

        <div class="search-group">
            <input type="text" id="searchInput" placeholder="S√∂k plats eller lat,lon">
            <button class="icon-btn" onclick="searchLocation()" title="S√∂k">üîç</button>
        </div>
        <button class="gps-btn" onclick="locateUser()">üìç G√• till min position</button>
        
        <hr style="border:0; border-top:1px solid #eee; width:100%; margin: 5px 0;">
        
        <div class="control-row">
            <span class="control-label">S√∂kradie (km):</span>
            <input type="number" id="radiusInput" value="5" min="0.5" max="100" step="0.5">
        </div>

        <div class="control-row">
            <span class="control-label">Antal punkter:</span>
            <input type="number" id="numPoints" value="5" min="1" max="50">
        </div>
        
        <div class="checkbox-group">
            <div class="checkbox-row">
                <input type="checkbox" id="show-circle" checked>
                <label for="show-circle">Visa radie</label>
            </div>
            
            <div class="checkbox-row">
                <input type="checkbox" id="lock-circle">
                <label for="lock-circle" title="L√•s cirkeln vid nuvarande plats">üîí L√•s radie</label>
            </div>
        </div>

        <button id="scan-btn" class="action-btn" onclick="analyzeTerrain()" disabled>üìç S√∂k punkter</button>
        <button class="clear-btn" onclick="clearResults()">üóëÔ∏è Rensa resultat</button>
        
        <div id="status">Redo.</div>
    </div>

    <canvas id="analysis-canvas"></canvas>
    <canvas id="single-point-canvas" width="1" height="1"></canvas>
    <div id="map"></div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // =================================================================
        // H√ÑR ST√ÑLLER DU IN DINA API-NYCKLAR
        // =================================================================
        
        // Thunderforest (Kr√§vs f√∂r Outdoors): Skapa gratis konto p√• thunderforest.com
        const TF_API_KEY = "DIN_THUNDERFOREST_NYCKEL_H√ÑR"; 

        // Lantm√§teriet (Kr√§vs f√∂r Topowebb): Skapa gratis konto p√• lantmateriet.se
        const LM_API_KEY = "DIN_LANTMATERIET_NYCKEL_H√ÑR"; 

        // =================================================================

        // --- KARTK√ÑLLOR ---
        
        // 1. OpenTopoMap (Standard)
        const OPENTOPO_URL = "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png";

        // 2. Tracetrack (Backup, bra detaljer)
        const TRACETRACK_URL = "https://tile.tracestrack.com/topo_sv/{z}/{x}/{y}.webp?key=ee0783bcbd92009d4c1b0b8e9a4d7e96";
        
        // 3. Thunderforest Outdoors
        const TF_OUTDOORS_URL = `https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey=${TF_API_KEY}`;

        // 4. Lantm√§teriet (Topowebb CC-BY)
        const LM_URL = `https://api.lantmateriet.se/open/topowebb-ccby/v1/wmts/token/${LM_API_KEY}/?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=topowebb&STYLE=default&TILEMATRIXSET=3857&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=image/png`;

        // 5. Satellit (Esri)
        const SATELLITE_URL = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}";
        
        // 6. Data (Osynlig, anv√§nds f√∂r analys)
        const DATA_TILE_URL = "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png";

        // Skapa lager-objekt
        const openTopoLayer = L.tileLayer(OPENTOPO_URL, { attribution: 'OpenTopoMap', maxZoom: 17 });
        const tracetrackLayer = L.tileLayer(TRACETRACK_URL, { attribution: 'Tracetrack', maxZoom: 19 });
        const satelliteLayer = L.tileLayer(SATELLITE_URL, { attribution: 'Esri', maxZoom: 19 });
        const debugLayer = L.tileLayer(DATA_TILE_URL, { attribution: 'Mapzen R√•data', maxZoom: 15, opacity: 1 });
        
        const thunderforestLayer = L.tileLayer(TF_OUTDOORS_URL, { 
            attribution: 'Thunderforest | OpenStreetMap', 
            maxZoom: 22 
        });

        const lantmaterietLayer = L.tileLayer(LM_URL, {
            attribution: 'Lantm√§teriet',
            maxZoom: 17
        });

        // Initiera kartan med OpenTopoMap som standard
        const map = L.map('map', { 
            zoomControl: false, 
            layers: [openTopoLayer] // STANDARDVAL H√ÑR
        }).setView([67.89, 18.52], 11);
        
        L.control.zoom({position: 'bottomright'}).addTo(map);

        // Lager-menyn
        const baseMaps = {
            "H√∂jdf√§rger (OpenTopo)": openTopoLayer,
            "Thunderforest Outdoors": thunderforestLayer, // Kr√§ver nyckel
            "Lantm√§teriet (Sverige)": lantmaterietLayer,  // Kr√§ver nyckel
            "Standard (Tracetrack)": tracetrackLayer,
            "Satellit (Esri)": satelliteLayer,
            "R√•data (Debug)": debugLayer
        };
        L.control.layers(baseMaps, null, { position: 'topright' }).addTo(map);

        const goldIcon = new L.Icon({
            iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
            shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
            iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
            className: 'gold-icon'
        });

        // --- Variabler ---
        let markers = [];
        let searchCircle = null;
        let centerMarker = null;
        let isLocked = false;
        let lockedCenterCoords = null;
        
        const canvas = document.getElementById('analysis-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const spCanvas = document.getElementById('single-point-canvas');
        const spCtx = spCanvas.getContext('2d', { willReadFrequently: true });

        // DOM Elements
        const crosshair = document.getElementById('crosshair');
        const liveLabel = document.getElementById('liveLabel');
        const statusDiv = document.getElementById('status');
        const centerHeightDisplay = document.getElementById('center-h');
        const scanBtn = document.getElementById('scan-btn');
        const zoomLabel = document.getElementById('zoom-level');
        const radiusInput = document.getElementById('radiusInput');
        const circleCheckbox = document.getElementById('show-circle');
        const lockCheckbox = document.getElementById('lock-circle');
        const searchInput = document.getElementById('searchInput');

        // --- EVENT LISTENERS ---
        searchInput.addEventListener("keypress", (e) => { if(e.key === "Enter") searchLocation(); });
        radiusInput.addEventListener('input', updateUI);
        circleCheckbox.addEventListener('change', updateUI);
        
        lockCheckbox.addEventListener('change', (e) => {
            isLocked = e.target.checked;
            
            if (isLocked) {
                // L√•s aktiverat
                lockedCenterCoords = map.getCenter();
                crosshair.style.display = 'block';
                liveLabel.textContent = "H√ñJD √ñVER HAVET VID KRYSSET";
            } else {
                // L√•s avaktiverat
                lockedCenterCoords = null;
                crosshair.style.display = 'none';
                liveLabel.textContent = "H√ñJD √ñVER HAVET VID MITTPUNKT";
            }
            updateUI();
        });

        // --- S√ñK & GPS ---
        async function searchLocation() {
            const query = searchInput.value.trim();
            if (!query) return;
            statusDiv.textContent = "S√∂ker...";
            const coordMatch = query.match(/^([-+]?\d{1,2}[.]?\d*)[,\s]+([-+]?\d{1,3}[.]?\d*)$/);
            if (coordMatch) {
                map.setView([parseFloat(coordMatch[1]), parseFloat(coordMatch[2])], 12);
                statusDiv.textContent = "Klar."; return;
            }
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
                const data = await response.json();
                if (data && data.length > 0) {
                    map.setView([parseFloat(data[0].lat), parseFloat(data[0].lon)], 12);
                    statusDiv.textContent = `Hittade: ${data[0].display_name.split(',')[0]}`;
                } else { statusDiv.textContent = "Ingen tr√§ff."; }
            } catch (error) { console.error(error); }
        }

        function locateUser() {
            if (!navigator.geolocation) { statusDiv.textContent = "GPS saknas."; return; }
            statusDiv.textContent = "H√§mtar pos...";
            navigator.geolocation.getCurrentPosition(
                (pos) => { map.setView([pos.coords.latitude, pos.coords.longitude], 13); statusDiv.textContent = "Klar."; },
                () => statusDiv.textContent = "GPS fel."
            );
        }

        window.clearResults = function() {
            markers.forEach(m => map.removeLayer(m));
            markers = [];
            statusDiv.textContent = "Rensat.";
        };

        window.copyCoords = function(lat, lng, btnElement) {
            navigator.clipboard.writeText(`${lat}, ${lng}`).then(() => {
                const originalText = btnElement.innerText;
                btnElement.innerText = "‚úÖ";
                setTimeout(() => btnElement.innerText = originalText, 1500);
            });
        };

        // --- UI FUNKTIONER ---
        function getSearchCenter() {
            return isLocked && lockedCenterCoords ? lockedCenterCoords : map.getCenter();
        }

        function updateUI() {
            zoomLabel.innerText = 'Zoom: ' + map.getZoom();
            const searchCenter = getSearchCenter(); 
            const radiusKm = parseFloat(radiusInput.value) || 5;
            
            if (searchCircle) map.removeLayer(searchCircle);
            if (centerMarker) map.removeLayer(centerMarker);
            
            if (circleCheckbox.checked) {
                searchCircle = L.circle(searchCenter, { 
                    color: isLocked ? '#e67e22' : '#007bff', 
                    fillColor: isLocked ? '#e67e22' : '#007bff', 
                    fillOpacity: 0.1, weight: 1, radius: radiusKm * 1000, interactive: false 
                }).addTo(map);

                centerMarker = L.circleMarker(searchCenter, { 
                    radius: 4, 
                    color: isLocked ? '#e67e22' : '#007bff', 
                    fillColor: '#ffffff', fillOpacity: 1, weight: 2, interactive: false 
                }).addTo(map);
            }
        }

        // --- H√ñJD-LOGIK (Live & Safe Check) ---
        async function updateCenterElevation() {
            const center = map.getCenter();
            
            scanBtn.disabled = true;
            centerHeightDisplay.textContent = "..."; 
            
            const zoom = Math.min(Math.floor(map.getZoom()), 14); 
            
            const point = map.project(center, zoom);
            const tileX = Math.floor(point.x / 256);
            const tileY = Math.floor(point.y / 256);
            const pixelX = Math.floor(point.x % 256);
            const pixelY = Math.floor(point.y % 256);

            const url = DATA_TILE_URL.replace('{z}', zoom).replace('{x}', tileX).replace('{y}', tileY);

            try {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = url;
                
                img.onload = () => {
                    spCtx.clearRect(0,0,1,1);
                    spCtx.drawImage(img, pixelX, pixelY, 1, 1, 0, 0, 1, 1);
                    const pData = spCtx.getImageData(0, 0, 1, 1).data;
                    const h = (pData[0] * 256 + pData[1] + pData[2] / 256) - 32768;
                    
                    centerHeightDisplay.textContent = Math.round(h) + " m";
                    scanBtn.disabled = false;
                };
                
                img.onerror = () => { 
                    centerHeightDisplay.textContent = "N/A"; 
                    scanBtn.disabled = true;
                };

            } catch (err) { 
                centerHeightDisplay.textContent = "N/A"; 
                scanBtn.disabled = true;
            }
        }

        map.on('zoomend', () => { updateUI(); updateCenterElevation(); });
        map.on('move', updateUI); 
        map.on('moveend', updateCenterElevation);
        
        updateUI();
        updateCenterElevation();

        // --- ANALYSLOGIK ---
        async function analyzeTerrain() {
            clearResults();
            scanBtn.disabled = true;
            statusDiv.textContent = "Laddar data...";

            try {
                const size = map.getSize();
                canvas.width = size.x;
                canvas.height = size.y;
                ctx.imageSmoothingEnabled = false; 
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const bounds = map.getBounds();
                const zoom = Math.min(Math.floor(map.getZoom()), 14); 
                
                const nw = map.project(bounds.getNorthWest(), zoom);
                const se = map.project(bounds.getSouthEast(), zoom);
                const tileMin = nw.divideBy(256).floor();
                const tileMax = se.divideBy(256).floor();

                const tilesToLoad = [];
                for (let x = tileMin.x; x <= tileMax.x; x++) {
                    for (let y = tileMin.y; y <= tileMax.y; y++) {
                        tilesToLoad.push({ x, y, z: zoom });
                    }
                }

                await loadAndDrawDataTiles(tilesToLoad, zoom, nw);

                statusDiv.textContent = "Ber√§knar...";
                requestAnimationFrame(() => {
                    findPeaks();
                    updateCenterElevation();
                });
            } catch (err) {
                console.error(err);
                statusDiv.textContent = "Fel: " + err.message;
                updateCenterElevation();
            }
        }

        function loadAndDrawDataTiles(tiles, zoom, nwPixelOrigin) {
            const promises = tiles.map(t => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = DATA_TILE_URL.replace('{z}', t.z).replace('{x}', t.x).replace('{y}', t.y);
                    img.onload = () => {
                        const tilePos = new L.Point(t.x * 256, t.y * 256);
                        const offset = tilePos.subtract(nwPixelOrigin); 
                        ctx.drawImage(img, Math.floor(offset.x), Math.floor(offset.y), 256, 256);
                        resolve();
                    };
                    img.onerror = () => resolve(); 
                });
            });
            return Promise.all(promises);
        }

        function findPeaks() {
            const w = canvas.width;
            const h = canvas.height;
            const imgData = ctx.getImageData(0, 0, w, h).data;
            const searchCenterLatLng = getSearchCenter();
            
            const maxRadiusMeters = (parseFloat(radiusInput.value) || 5) * 1000;
            let candidates = [];

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    if (imgData[i+3] < 255) continue; 
                    const height = (imgData[i] * 256 + imgData[i+1] + imgData[i+2] / 256) - 32768;
                    if (height > -50) candidates.push({ x, y, h: height });
                }
            }

            const validPeaks = [];
            for (let p of candidates) {
                const latlng = map.containerPointToLatLng([p.x, p.y]);
                const dist = searchCenterLatLng.distanceTo(latlng); 
                if (dist <= maxRadiusMeters) {
                    p.dist = dist; p.lat = latlng.lat; p.lng = latlng.lng;
                    validPeaks.push(p);
                }
            }
            validPeaks.sort((a, b) => b.h - a.h);

            const finalPoints = [];
            const limit = parseInt(document.getElementById('numPoints').value) || 5;
            const minPixelDist = 40; 
            for (let p of validPeaks) {
                if (finalPoints.length >= limit) break;
                let tooClose = false;
                for (let existing of finalPoints) {
                    const dx = p.x - existing.x;
                    const dy = p.y - existing.y;
                    if ((dx*dx + dy*dy) < (minPixelDist * minPixelDist)) { tooClose = true; break; }
                }
                if (!tooClose) finalPoints.push(p);
            }

            if (finalPoints.length === 0) { statusDiv.textContent = "Inga toppar."; return; }

            finalPoints.forEach((p, idx) => {
                const distKm = (p.dist / 1000).toFixed(2);
                const isHighest = (idx === 0);
                const markerOptions = isHighest ? { icon: goldIcon, zIndexOffset: 1000 } : {};

                const popupContent = `
                    <span class="popup-header" style="${isHighest ? 'color:#b8860b' : ''}">${isHighest ? 'üèÜ ' : ''}Plats #${idx+1}</span>
                    <span class="popup-height">${Math.round(p.h)} m √∂.h</span>
                    <span class="popup-meta">Avst√•nd: ${distKm} km</span>
                    <div class="coord-box">
                        <span>${p.lat.toFixed(5)}, ${p.lng.toFixed(5)}</span>
                        <button class="copy-btn" title="Kopiera" onclick="copyCoords(${p.lat.toFixed(5)}, ${p.lng.toFixed(5)}, this)">üìã</button>
                    </div>`;

                const marker = L.marker([p.lat, p.lng], markerOptions).addTo(map).bindPopup(popupContent);
                if (isHighest) marker.openPopup();
                markers.push(marker);
            });
            statusDiv.textContent = `Hittade ${finalPoints.length} punkter.`;
        }
    </script>
</body>
</html>
